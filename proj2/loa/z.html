<!DOCTYPE html>
<!-- saved from url=(0052)https://inst.eecs.berkeley.edu/~cs61b/fa15/hw/proj3/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Project 3 | CS 61B Fall 2015</title>
    <meta charset="UTF-8">

    <link href="./z_files/css" rel="stylesheet" type="text/css">
    <link href="./z_files/css(1)" rel="stylesheet" type="text/css">
    <link href="./z_files/common.css" rel="stylesheet" type="text/css">
    <link href="./z_files/lab.css" rel="stylesheet" type="text/css">
    <link href="./z_files/proj.css" rel="stylesheet" type="text/css">

    <script src="./z_files/jquery-1.11.2.min.js" type="text/javascript"></script><style type="text/css"></style>
</head>
<body>
    <div class="navbar-top"><div id="navitems">
        <a href="https://inst.eecs.berkeley.edu/~cs61b/fa15/index.html"><div class="navitem">Main</div></a>
        <a href="https://inst.eecs.berkeley.edu/~cs61b/fa15/about.html"><div class="navitem">Course Info</div></a>
        <a href="https://inst.eecs.berkeley.edu/~cs61b/fa15/TA.html"><div class="navitem">Staff</div></a>
        <a href="https://inst.eecs.berkeley.edu/~cs61b/fa15/assign.html"><div class="navitem">Assignments</div></a>
        <a href="https://inst.eecs.berkeley.edu/~cs61b/fa15/resources.html"><div class="navitem">Resources</div></a>
        <a href="https://piazza.com/class/idpl6lpmso7ws"><div class="navitem">Piazza</div></a>
    </div></div>
    <main class="content">
        <header class="title">Project 3: Gitlet, your own version-control system</header>
<p>In a departure from our usual practice, we will allow partnerships.
Both partners will get the same grade.  We'll  will assign
partners to those who want them and do not choose one.</p>

<p>[The skeleton, containing an autograder and utilities, is still in progress.
We'll let you know when it is released.  Your project, as usual, will go into
a subdirectory named <code>proj3</code>.]</p>


<h2 id="a-overview-of-gitlet">A. Overview of Gitlet</h2>


<p>In this project you'll be implementing a version-control system. This
version-control system mimics some of the basic features of the
popular version-control system <a href="http://git-scm.com/">git</a>, but it is
smaller and simpler, so we have named it gitlet.</p>

<p>A version-control system is essentially a backup system for files on
your computer. The main functionality that gitlet supports is:</p>

<ol>
  <li>Saving backups of directories of files.
  In gitlet, this is called <em>committing</em>, and the backups themselves are
  called <em>commits</em>.</li>
  <li>Restoring a backup version of one or more files or entire commits.
  In gitlet, this is called <em>checking out</em> those files or that commit.</li>
  <li>Viewing the history of your backups. In gitlet, you view this
  history in something called the <em>log</em>.</li>
  <li>Maintaining related sequences of commits, called <em>branches</em>.</li>
  <li>Merging changes made in one branch into another.</li>
</ol>

<p>The point of a version-control system is to help you when coding
complicated projects, or when collaborating with others on a project.
You save versions of the project periodically.
If at some later point in time you
accidentally mess up your code, then you can restore your source to
a previously committed version (without losing any of the changes
you made since then).</p>

<p>In gitlet, you don't just commit individual files at a time. Instead,
you can commit an arbitrary set files at the same time. We like to think of
each commit as a <em>snapshot</em> of your entire project at one point
in time. However, for simplicity, many of the examples in the
remainder of this document involve just committing one file at a time.
Just keep in mind you could add in multiple files to each commit.</p>

<p>In this project, it will be helpful for us to visualize the commits we
make over time. Suppose we have a file wug.txt, we add some text to
it, and commit it. Then we modify the file and commit these changes.
Then we modify the file again, and commit the changes again. Now we
have saved three total backup versions of this file, each one further
in time than the previous. We can visualize these commits like so:</p>

<p><img src="./z_files/three_commits.png" alt="Three commits"></p>

<p>Here we've drawn an arrow indicating that each commit contains some
kind of reference to the commit that came before it. We call the
commit that came before it the parent commit — this will be important
later. But for now, does this drawing look familiar? That's right;
it's a linked list!</p>

<p>The big idea behind gitlet is that we can visualize the history of the
different versions of our files in a list like this. Then it's easy
for us to restore old versions of files. You can imagine making a
command like: "Gitlet, please revert to the state of the files at
commit #2", and it would go to the second node in the linked list and
restore the copies of files found there.</p>

<p>If we tell gitlet to revert to an old commit, the front of the linked
list will no longer reflect the current state of your files, which
might be a little misleading. In order to fix this problem, we
introduce something called the <em>head</em> pointer. The head pointer keeps
track of where in the linked list we're currently "at". Normally, as
we make commits, the head pointer will stay at the front of the linked
list, indicating that the latest commit reflects the current state of
the files:</p>

<p><img src="./z_files/simple_head.png" alt="Simple head"></p>

<p>However, let's say we revert to the state of the files at commit #2
(technically, this is the <em>reset</em> command, which you'll see later in
the spec). We move the head pointer back to show this:</p>

<p><img src="./z_files/reverted_head.png" alt="Reverted head"></p>

<p>All right, now, if this were all gitlet could do, it would be a pretty
simple system. But gitlet has one more trick up its sleeve: it doesn't
just maintain older and newer versions of files, it can maintain
<em>differing</em> versions. Imagine you're coding a project, and you have
two ideas about how to proceed: let's call one Plan A, and the other
Plan B. Gitlet allows you to save both versions, and switch between
them at will. Here's what this might look like, in our pictures:</p>

<p><img src="./z_files/two_versions.png" alt="Two versions"></p>

<p>It's not really a linked list anymore. It's more like a tree. We'll
call this thing the commit tree. Keeping with this metaphor, each of
the separate versions is called a <em>branch</em> of the tree. You can
develop each version separately:</p>

<p><img src="./z_files/two_developed_versions.png" alt="Two developed versions"></p>

<p>There are two pointers into the tree, representing the furthest
point of each branch. At any given time, only one of these is the
currently active pointer, and this what's called the head pointer. The
head pointer is the pointer at the front of the current branch.</p>

<p>That's it for our brief overview of the gitlet system! Don't worry if
you don't fully understand it yet; the section above was just to give
you a high level picture of what its meant to do. A detailed spec of
what you're supposed to do for this project follows this section.</p>

<p>But a last word here: one feature of the commit tree that it is in
some sense <em>immutable</em>: once a commit node has been created, it can
never be destroyed (or changed at all). We can only add new things to
the commit tree, not modify existing things. This is an important
feature of gitlet! Remember, it's a version-control system, and one of
our goals with it is to allow us to save things so we don't delete
them accidentally.</p>


<h2 id="b-internal-structures">B. Internal Structures</h2>


<p>Real <code>git</code> distinguishes several different kinds of <em>objects</em>.  For
our purposes, the important ones are</p>

<ul>
  <li><strong><em>blobs</em></strong>: Essentially the contents of files.</li>
  <li><strong><em>trees</em></strong>: Directory structures mapping names to references to blobs and
  other trees (subdirectories).</li>
  <li><strong><em>commits</em></strong>: Combinations of log messages,
  other metadata (commit date, author,
  etc.), a reference to a tree, and references to
  parent commits.
  The repository also maintains a mapping from <em>branch heads</em> (we've used names
  like  <code>master</code>, <code>proj2</code>, etc.) to references to commits, so that
  certain important commits have symbolic names.</li>
</ul>

<p>We will simplify from <code>git</code> still
further by</p>

<ul>
  <li>Incorporating trees into commits and not dealing with subdirectories (so
  there will be one
  "flat" directory of plain files for each repository).</li>
  <li>Having a single parent commit associated with each commit.</li>
  <li>Our metadata will consist only of a timestamp and log message.
  A commit, therefore, will consist of a log message, 
  timestamp, a mapping of file names to blob references, and a single parent
  reference.</li>
</ul>

<p>Every object — every blob and every commit in our case — has a unique
integer id that serves as a reference to the object.
An interesting feature of <code>git</code> is that these ids are <em>universal</em>:  unlike a
typical Java implementation, two objects with exactly the same content will
have the same id on all systems.  In the case of blobs, "same content" means
the same file contents.  In the case of commits, it means the same metadata,
the same mapping of names to references, and the same parent reference.
The objects in a repository are thus said to be <em>content addressable</em>.</p>

<p>Both <code>git</code> and <code>gitlet</code> accomplish this the same way: by using a <em>cryptographic
hash function</em> called SHA-1 (Secure Hash 1), which produces a 160-bit integer
hash from any sequence of bytes. Cryptographic hash functions have the property
that it is extremely difficult to find two different byte streams with the
same hash value (or indeed to find <em>any</em> byte stream given just its hash value),
so that essentially, we may assume that the probability of
that any two objects with different contents have the same SHA-1 hash value is
2<sup>-160</sup> or about 10<sup>-48</sup>.  Basically, we simply ignore the
possibility of a hashing collision, so that the system has, in principle,
a fundamental bug that in practice never occurs!</p>

<p>Fortunately, there are library classes for computing SHA-1 values, so you won't
have to deal with the actual algorithm.
All you have to do is to make sure that you
correctly label all your objects.  In particular, this involves</p>

<ul>
  <li>Including all metadata and references when hashing a commit.</li>
  <li>Distinguishing somehow between hashes for commits and hashes for blobs.  A
  good way to do so is to hash in an extra word for each object that
  has one value for blobs and another for commits.</li>
</ul>

<p>By the way, the SHA-1 hash value, rendered as a 40-character
hexadecimal string, makes
a convenient file name for storing your data in your <code>.gitlet</code>
directory (more on that below).  It also gives you a convenient way to
compare two files (blobs) to see if they have the same contents: if their
SHA-1s are the same, we simply assume the files are the same.</p>

<p>For remotes (like <code>origin</code> and <code>shared</code>, which we've been using all semester),
we'll simply use other <code>gitlet</code> repositories.  Pushing simply means copying all
commits and blobs that the remote repository does not yet have to the remote
repository, and resetting a branch reference.  Pulling is the same, but in the
other direction</p>

<p>Reading and writing your internal objects from and to files is actually pretty
easy, thanks to Java's <em>serialization</em> facilities.  The interface
<code>java.io.Serializable</code> has no methods,
but if a class implements it, then the Java
runtime will automatically provide a way to convert to and from a stream of
bytes, which you can then write to a file using the I/O class
<code>java.io.ObjectOutputStream</code> and read back (and deserialize) with
<code>java.io.ObjectInputStream</code>).
The term "serialization" refers to the conversion from some arbitrary structure
(array, tree, graph, etc.) to a serial sequence of bytes.</p>

<p>Here is a summary example of the structures discussed in this section.
As you can see, each commit (rectangle) points to some blobs (circles), which
contain file contents.  The commits contain the file names and references to
these blobs, as well as a parent link.  These references, depicted as arrows,
are represented in the <code>.gitlet</code> directory using their SHA-1 hash values (the
small hexdecimal numerals above the commits and below the blobs).  The newer
commit contains an updated version of <code>wug1.txt</code>, but shares the same version
of <code>wug2.txt</code> as the older commit.</p>

<p><img src="./z_files/commits-and-blobs.png" alt="Two commits and their blobs"></p>


<h2 id="c-detailed-spec-of-behavior">C. Detailed Spec of Behavior</h2>



<h4 id="overall-spec">Overall Spec</h4>


<p>The only structure requirement we're giving you is that you have a
class named Gitlet and that it has a main method. Here's your skeleton
code for this project (in package <code>gitlet</code>):</p>

<pre><code>public class Main {
    public static void main(String[] args) {
       // FILL IN
    }
}</code></pre>

<p>We are also giving you some utility methods for performing a number of
mostly file-system-related tasks, so that you can concentrate on the logic
of the project rather than the peculiarities of dealing with the OS.</p>

<p>You may, of course, write additional Java classes to support your
project — in fact, please do. But don't use any external code (aside
from JUnit), and don't use any programming language other than Java.
You can use all of the Java Standard Library that you wish, plus utilities we
provide.</p>

<p>The majority of this spec will describe how <code>Gitlet.java</code>'s main
method must react when it receives various arguments which correspond
to commands to the gitlet system. But before we break down command-by-
command, here are some overall guidelines the whole project should
satisfy:</p>

<ul>
  <li>In order for gitlet to work, it will need a place to store old
  copies of files (it is a backup system, after all), and other
  metadata. All of this stuff <strong>must</strong> be stored in a directory called
  <code>.gitlet</code>, just as this information is stored in directory <code>.git</code> for the
  real git system (files with a <code>.</code> in front are hidden files. You will
  not be able to see them by default on most operating systems.  One Unix,
  the command <code>ls -a</code> will show them.) A
  gitlet system is considered "initialized" in a particular location if
  it has a <code>.gitlet</code> directory there. Most gitlet commands (except for the
  init command) only need to work when used from a directory where a
  gitlet system has been initialized — i.e. a directory that has a
  <code>.gitlet</code> directory. The files that <em>aren't</em> in your <code>.gitlet</code>
  directory (i.e. the current versions of the files, not the backups), are
  referred to as the files in your <em>working directory</em>.</li>
  <li>Most commands have runtime or memory usage requirements. You must
  follow these. Some of the runtimes are described as constant
  "relative to any significant measure". The significant measures are:
  any measure of number or size of files, any measure of number of
  commits. You can ignore time required to serialize or deserialize,
  <em>with the one caveat that your serialization time cannot depend in
  any way on the total size of files that have been added, committed,
  etc</em> (what is serialization? You'll see later in the spec). You can
  also pretend that getting from a hash table is constant time.</li>
  <li>Some commands have failure cases with a specified error message. The
  exact formats of these are specified later in the spec. If your
  program ever encounters one of these failure cases, it must print
  the error message and not change anything else. <em>You don't need to
  handle any other error cases except the ones listed as failure
  cases</em>.</li>
  <li><p>There are some failure cases you need to handle that don't apply to
  a particular command. Here they are:</p>

  <ul>
    <li>If a user doesn't input any arguments, print the message:
    <code>Please enter a command.</code> and exit.</li>
    <li>If a user inputs a command that doesn't exist, print the
    message: <code>No command with that name exists.</code> and exit.</li>
  </ul></li>
  <li>Some of the commands have their differences from the real git
  listed. The spec is not exhaustive in listing <em>all</em> differences from
  git, but it does list some of the bigger or potentially confusing
  and misleading ones.</li>
  <li>Do <strong>NOT</strong> print out anything except for what the spec says. Some of
  our autograder tests will break if you print anything more than
  necessary.</li>
  <li>The spec classifies some commands as "dangerous". Dangerous commands
  are ones that potentially overwrite files (that aren't just
  metadata) — for example, if a user tells gitlet to restore files to
  older versions, gitlet may overwrite the current versions of the
  files. Just FYI.</li>
</ul>


<h2 id="d-the-commands">D. The Commands</h2>



<h4 id="init">init</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main init</code></li>
  <li><strong>Description</strong>: Creates a new gitlet version-control system in the
  current directory. This system will automatically start with one
  commit: a commit that contains no files and has the commit message
  <code>initial commit</code>.</li>
  <li><strong>Runtime</strong>: Should be constant relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If there is already a gitlet version-control
  system in the current directory, it should abort. It should NOT
  overwrite the existing system with a new one. Should print the error
  message <code>A gitlet version-control system already exists in the
  current directory.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~20 -->


<h4 id="add">add</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main add [file name]</code></li>
  <li><strong>Description</strong>: Adds a copy of the file as it currently exists to
  the <em>staging area</em> (see the description of the <code>commit</code>
  command).  For this reason, adding a file is also
  called staging the file. The staging area should be somewhere in
  <code>.gitlet</code>.</li>
  <li><strong>Runtime</strong>: In the worst case, should run in linear time relative
  to the size of the file being added.</li>
  <li><strong>Failure cases</strong>: If the file does not exist, print the error
  message <code>File does not exist.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~20 -->


<h4 id="commit">commit</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main commit [message]</code></li>
  <li><p><strong>Description</strong>: Saves a snapshot of certain files in the current commit
  and staging area so they can be
  restored at a later time, creating a new commit. 
  The commit is said to be <em>tracking</em> the saved files. By default,
  each commit's snapshot of files will be exactly the same as its
  parent commit's snapshot of files; it will keep versions of files
  exactly as they are, and not update them. A commit will only update
  files it is tracking that have been staged at
  the time of commit, in which case the commit will now include the
  version of the file that was staged instead of the version it got
  from its parent. A commit will save and start tracking any files
  that were staged but weren't tracked by its parent.  Finally, files tracked
  in the current commit may be untracked in the new commit as a result of the
  <code>rm</code> command (below).</p>

  <p>The bottom line: By default a commit is the same as its parent.
  Staged and removed files are the updates to the commit.</p>

  <p>Some additional points about commit:</p>

  <ul>
    <li>The staging area is cleared after a commit.</li>
    <li>The commit command never adds, changes, or removes files in the
    working directory (other than those in the <code>.gitlet</code> directory).  The
    <code>rm</code> command <em>will</em> remove such files, as well as somehow
    marking them to be untracked by <code>commit</code>.</li>
    <li>Any changes made to files after staging or removal are ignored by the
    <code>commit</code> command, which <em>only</em> modifies the contents of the <code>.gitlet</code>
    directory.  For example, if you remove a tracked file using the Unix
    <code>rm</code> command (rather than <code>gitlet</code>'s command of the same name), it has
    no effect on the next commit, which will still contain the deleted version
    of the file.</li>
    <li>After the commit command, the new commit is added as a new node
    in the commit tree.</li>
    <li>The commit just made becomes the "current commit", and the head
    pointer now points to it. The previous head commit is this
    commit's parent commit.</li>
    <li>Each commit should contain the date time it was made.</li>
    <li>Each commit has a log message associated with it that describes the
    changes to the files in the commit. This is specified by the
    user. The entire message should take up only one entry in
    the array <code>args</code> that is passed to <code>main</code>. To include multiword
    messages, you'll have to surround them in quotes.</li>
    <li>Each commit is identified by its SHA-1 id, which must include the
    file (blob) references of its files,
    parent reference, log message, and commit time.</li>
  </ul></li>
  <li><strong>Runtime</strong>: Runtime should be constant with respect to any measure
  of number of commits. Runtime must be no worse than linear with
  respect to the total size of files the commit is tracking.
  Additionally, this command has a memory requirement: Committing must
  increase the size of the <code>.gitlet</code> directory by no more than the total
  size of the staged files at the time of commit, not including
  additional metadata. This means don't store redundant copies of
  versions of files that a commit receives from its parent. One more
  You <em>are</em> allowed to save whole additional copies of files;
  don't worry about only saving diffs, or anything like that.</li>
  <li><strong>Failure cases</strong>: If no files have been staged (or marked for
  untracking: more on that next), aborts. Print the message <code>No
  changes added to the commit.</code> Every commit must have a non-
  blank message. If it doesn't, print the error message <code>Please enter
  a commit message.</code> It is <em>not</em> a failure for tracked files to be 
  missing from the working directory or changed in the working directory.
  Just ignore everything outside the <code>.gitlet</code> directory entirely.</li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Differences from real git</strong>: In real git, commits may have multiple
  parents (due to merging) and also have considerably more metadata.</li>
</ul>

<!-- - __Our line count__: ~40 -->

<p>Here's a picture of before-and-after commit:</p>

<p><img src="./z_files/before_and_after_commit.png" alt="Before and after commit"></p>


<h4 id="rm">rm</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rm [file name]</code></li>
  <li><strong>Description</strong>: Untrack the file; that is, indicate (somewhere in the 
  <code>.gitlet</code> directory) that it is <em>not</em> to be included in the next commit,
  even if it is tracked in
  the current commit (which will become the next commit's parent).
  Remove the file from the working directory if it
  was tracked in the current commit.
  If the file had been staged, then
  unstage it, but <em>don't</em> remove it from the working directory unless it was
  tracked in the current commit.</li>
  <li><strong>Runtime</strong>: Should run in constant time relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If the file is neither staged nor tracked by the
  head commit, print the error message <code>No reason to remove the file.</code></li>
  <li><strong>Dangerous?</strong>: Yes (although if you use our utility methods, you will only
  hurt your repository files, and not all the other files in your
  directory.)</li>
</ul>

<!-- - __Our line count__: ~5 -->


<h4 id="log">log</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main log</code></li>
  <li><p><strong>Description</strong>: Starting at the current head commit, display
  information about each commit backwards along the commit tree until
  the initial commit. This set of commit nodes is called the commit's
  <em>history</em>. For every node in this history, the information it should
  display is the commit id, the time the commit was made, and the
  commit message. Here is an example of the <em>exact</em> format it should
  follow:</p>

<pre><code>===
Commit a0da1ea5a15ab613bf9961fd86f010cf74c7ee48
2015-03-14 11:59:26
A commit message.

===
Commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff
2015-03-14 11:49:29
Another commit message.

===
Commit e881c9575d180a215d1a636545b8fd9abfb1d2bb
2015-03-14 11:39:26
initial commit</code></pre>

  <p>There is a <code>===</code> before each commit and an empty line after it. 
  As in real <code>git</code>, each entry displays the unique SHA-1 id of the commit
  object.
  Display commits with the most recent at the top. By the way, there's a
  class in the Java standard library that will help you format the
  dates really easily. Look into that instead of trying to construct
  it manually yourself!</p></li>
  <li><strong>Runtime</strong>: Should be linear with respect to the number of nodes in
  head's history.</li>
  <li><strong>Failure cases</strong>: None</li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~5 -->

<p>Here's a picture of the history of a particular commit. If the current
branch's head pointer happened to be pointing to that commit, log
would print out information about the circled commits:</p>

<p><img src="./z_files/history.png" alt="History"></p>

<p>The history ignores other branches and the future. Now that we have
the concept of history, let's refine what we said earlier about the
commit tree being immutable. It is immutable precisely in the sense
that <em>the history of a commit with a particular id may never change,
ever</em>. If you think of the commit tree as nothing more than a
collection of histories, then what we're really saying is that each
history is immutable.</p>


<h4 id="global-log">global-log</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main global-log</code></li>
  <li><strong>Description</strong>: Like log, except displays information about all
  commits ever made. The order of the commits does not matter.</li>
  <li><strong>Runtime</strong>: Linear with respect to the number of commits ever made.</li>
  <li><strong>Failure cases</strong>: None</li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~5 -->


<h4 id="find">find</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main find [commit message]</code></li>
  <li><strong>Description</strong>: Prints out the ids of all commits that have the given
  commit message, one per line.
  If there are multiple such commits, it prints the
  ids out on separate lines.</li>
  <li><strong>Runtime</strong>: Should be linear relative to the number of commits.</li>
  <li><strong>Failure cases</strong>: If no such commit exists, prints the error
  message <code>Found no commit with that message.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
  <li><strong>Differences from real git</strong>: Doesn't exist in real git. Similar
  effects can be achieved by grepping the output of log.</li>
</ul>

<!-- - __Our line count__: ~5 -->


<h4 id="status">status</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main status</code></li>
  <li><p><strong>Description</strong>: Displays what branches currently exist, and marks
  the current branch with a <code>*</code>. Also displays what files have been
  staged or marked for untracking. An example of the <em>exact</em> format it
  should follow is as follows.</p>

<pre><code>=== Branches ===
*master
other-branch

=== Staged Files ===</code></pre>

  <p>wug2.txt</p>

<pre><code>wug.txt

=== Removed Files ===
goodbye.txt

=== Modifications Not Staged For Commit ===</code></pre>

  <p>junk.txt (deleted)
  	wug3.txt (modified)</p>

<pre><code>=== Untracked Files ===</code></pre>

  <p>random.stuff</p>

  <p>There is an empty line between each section. Entries should be listed in
  lexicographic order, using the Java string-comparison order (the asterisk
  doesn't count).  A file in the working directory
  is "modified but not staged" if</p></li>
  <li>Changed in the working directory, but not staged; or</li>
  <li>Staged, but with different contents than in the working directory; or</li>
  <li>Staged, but deleted in the working directory; or</li>
  <li><p>Not staged, but tracked and deleted in the working directory.</p>

  <p>The final category ("Untracked Files") is for files present in the working
  directory but not tracked.</p></li>
  <li><strong>Runtime</strong>: Make sure this is linear relative to the number of
  files that have been staged or marked for untracking and the number
  of branches that exist.</li>
  <li><strong>Failure cases</strong>: None</li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~15 -->


<h4 id="checkout">checkout</h4>


<p>Checkout is a kind of general command that can do a few different
things depending on what its arguments are. There are 3 possible use
cases. In each section below, you'll see 3 bullet points. Each
corresponds to the respective usage of checkout.</p>

<ul>
  <li><p><strong>Usages</strong>:</p>

  <ol>
    <li><code>java gitlet.Main checkout -- [file name]</code></li>
    <li><code>java gitlet.Main checkout [commit id] -- [file name]</code></li>
    <li><code>java gitlet.Main checkout [branch name]</code></li>
  </ol></li>
  <li><p><strong>Descriptions</strong>:</p>

  <ol>
    <li>Takes the version of the file as it exists in the head commit,
    the front of the current branch, and puts it in the working directory,
    overwriting the version of the file that's already there if there is
    one.</li>
    <li>Takes the version of the file as it exists in the commit with
    the given id, and puts it in the working directory, overwriting
    the version of the file that's already there if there is one.</li>
    <li>Takes all files in the commit at the head of the given branch,
    and puts them in the working directory, overwriting the versions
    of the files that are already there if they exist. Also, at the
    end of this command, the given branch will now be considered the
    current branch (HEAD).  Any files that are tracked in the current
    directory but are not present in the checked-out branch are deleted.</li>
  </ol></li>
  <li><p><strong>Runtimes</strong>:</p>

  <ol>
    <li>Should be linear relative to the size of the file being checked out.</li>
    <li>Should be linear relative to the size of the file being checked out.</li>
    <li>Should be linear with respect to the total size of the files in
    the commit's snapshot. Should be constant with respect to any
    measure involving number of commits. Should be constant with
    respect to the number of branches.</li>
  </ol></li>
  <li><p><strong>Failure cases</strong>:</p>

  <ol>
    <li>If the file does not exist in the previous commit, aborts,
    printing the error message <code>File does not exist in the most
    recent commit, or no such branch exists.</code></li>
    <li>If no commit with the given id exists, print <code>No commit with
    that id exists.</code> Else, if the file does not exist in the given
    commit, print <code>File does not exist in that commit.</code></li>
    <li>If no branch with that name exists, print <code>File does not exist
    in the most recent commit, or no such branch exists.</code> If that
    branch is the current branch, print <code>No need to checkout the
    current branch.</code>  If a working file is untracked in the current
    branch and would be overwritten by the checkout, print
    <code>There is an untracked file in the way; delete it or add it first.</code></li>
  </ol></li>
</ul>

<p>A [commit id] is, as described earlier, a hexadecimal numeral.  A convenient
feature of real <code>git</code> is that one can abbreviate commits with a unique
prefix.  For example, one might abbreviate</p>

<pre><code>a0da1ea5a15ab613bf9961fd86f010cf74c7ee48</code></pre>

<p>as</p>

<pre><code>a0da1e</code></pre>

<p>in the (likely) event that no other object exists with a SHA-1 identifier that
starts with the same six digits.  You should arrange for the same thing to
happen for commit ids that contain fewer than 40 characters.  Unfortunately,
using shortened ids might slow down the finding of objects if implemented
naively (making the time to find a file linear in the number of objects), so
we won't worry about timing for commands that use shortened ids.  We suggest,
however, that you poke around in a <code>.git</code> directory (specifically,
<code>.git/objects</code>) and see how it manages to speed up its search. You will perhaps
recognize a familiar data structure implemented with the file system rather
than pointers.</p>

<p>None of these versions modifies the staging area: files scheduled for 
addition or removal remain so.</p>

<ul>
  <li><strong>Dangerous?</strong>: Yes!</li>
</ul>

<!-- - __Our line counts__: 

<pre><code>&#x2d; ~20
&#x2d; ~20
&#x2d; ~20&#x2d;&#x2d;&gt;</code></pre>

#### branch

<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main branch [branch name]</code></li>
  <li><strong>Description</strong>: Creates a new branch with the given name, and
  points it at the current head node. A branch is nothing more than a
  name for a reference (a SHA-1 identifier)
  to a commit node. This command does NOT immediately switch to the newly
  created branch (just as in real <code>git</code>).
  Before you
  ever call branch, your code should be running with a default branch
  called "master".</li>
  <li><strong>Runtime</strong>: Should be constant relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name already exists,
  print the error message <code>A branch with that name already exists.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~5 -->

<p>All right, let's see what branch does in detail. Suppose our state
looks like this:</p>

<p><img src="./z_files/simple_history.png" alt="Simple history"></p>

<p>Now we call <code>java gitlet.Main branch cool-beans</code>. Then we get this:</p>

<p><img src="./z_files/just_called_branch.png" alt="Just called branch"></p>

<p>Hmm... nothing much happened. Let's switch to the branch with <code>java
Gitlet checkout cool-beans</code>:</p>

<p><img src="./z_files/just_switched_branch.png" alt="Just switched branch"></p>

<p>Nothing much happened again?! Okay, say we make a commit now. Modify
some files, then <code>java gitlet.Main add...</code> then <code>java gitlet.Main commit...</code>.</p>

<p><img src="./z_files/commit_on_branch.png" alt="Commit on branch"></p>

<p>I was told there would be branching. But all I see is a straight line.
What's going on? Maybe I should go back to my other branch with <code>java
Gitlet checkout master</code>:</p>

<p><img src="./z_files/checkout_master.png" alt="Checkout master"></p>

<p>Now I make a commit...</p>

<p><img src="./z_files/branched.png" alt="Branched"></p>

<p>Phew! So that's the whole idea of branching. Did you catch what's
going on? All that creating a branch does is to give us a new pointer. At any
given time, one of these pointers is considered the currently active
pointer, or the head pointer (indicated by *). We can switch the
currently active head pointer with <code>checkout [branch name]</code>. Whenever
we commit, it means we add a new commit in front of the currently
active head pointer, even if one is already there. This naturally
creates branching behavior.</p>

<p>Make <em>sure</em> that the behavior of your <code>branch</code>, <code>checkout</code>, and
<code>commit</code> match what we've described above. This is pretty core
functionality of gitlet that many other commands will depend upon. If
any of this core functionality is broken, very many of our autograder
tests won't work!</p>


<h4 id="rm-branch">rm-branch</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rm-branch [branch name]</code></li>
  <li><strong>Description</strong>: Deletes the branch with the given name. This only
  means to delete the pointer associated with the branch; it does not
  mean to delete all commits that were created under the branch, or
  anything like that.</li>
  <li><strong>Runtime</strong>: Should be constant relative to any significant measure.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name does not exist,
  aborts. Print the error message <code>A branch with that name does not
  exist.</code> If you try to remove the branch you're currently on, aborts,
  printing the error message <code>Cannot remove the current branch.</code></li>
  <li><strong>Dangerous?</strong>: No</li>
</ul>

<!-- - __Our line count__: ~5 -->


<h4 id="reset">reset</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main reset [commit id]</code></li>
  <li><strong>Description</strong>: Checks out all the files tracked by the given
  commit. Also moves the current branch's head to that commit node.
  See the intro for an example of what happens to the head pointer
  after using reset.  The <code>[commit id]</code> may be abbreviated as for
  <code>checkout</code>.</li>
  <li><strong>Runtime</strong>: Should be linear with respect to the total size of
  files tracked by the given commit's snapshot. Should be constant
  with respect to any measure involving number of commits.</li>
  <li><strong>Failure case</strong>: If no commit with the given id exists, print <code>No
  commit with that id exists.</code></li>
  <li><strong>Dangerous?</strong>: Yes!</li>
  <li><strong>Differences from real git</strong>: This command is
  closest to using the <code>--hard</code> option, as in <code>git reset --hard [commit
  hash]</code>.</li>
</ul>

<!-- - __Our line count__: ~10 -->


<h4 id="merge">merge</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main merge [branch name]</code></li>
  <li><p><strong>Description</strong>: Merges files from the given branch into the current
  branch. This method is a bit complicated, so here's a more detailed
  description:</p>

  <ul>
    <li>First consider what might be called the <em>split point</em> of the
    current branch and the given branch. This is their earliest common
    ancestor in the commit tree. <img src="./z_files/split_point.png" alt="Split point">
    If the split point <em>is</em> the same commit as the given branch, then
    we do nothing; the merge is complete, and the operation ends.
    If the split point is the current branch, then the current branch
    is set to the same commit as the given branch and the operation
    ends (this is known as fast forwarding).  Otherwise, we continue
    with the steps below.</li>
    <li>Any files that have been <em>modified</em> in the given branch since
    the split point, but not modified in the current branch since
    the split point should be changed to their versions in the given
    branch (checked out from the commit at the front of the given
    branch). These files should then all be automatically staged.
    To clarify, if a file is "modified in the given branch since the
    split point" this means the version of the file as it exists in
    the commit at the front of the given branch has different
    content from the version of the file at the split point.</li>
    <li>Any files that have been modified in the current branch but not
    in the given branch since the split point should stay as they
    are.</li>
    <li>Any files that were not present at the split point and are
    present only in the current branch should remain as they are.</li>
    <li>Any files that were not present at the split point and are
    present only in the given branch should be checked out and
    staged.</li>
    <li>Any files present at the split point, unmodified in the current branch
    branch, and absent in the given branch should be removed (and untracked).</li>
    <li>Any files present at the split point, unmodified in the given branch,
    and absent in the current branch should remain absent.</li>
    <li><p>Any files modified in different ways
    in the current and given branches are <em>in conflict</em>.  "Modified in 
    different ways" can mean that the contents of both are changed and
    different from other, or the contents of one are changed and the other
    is deleted, or the file was absent at the split point and have different
    contents in the given and current branches.  In this case, replace
    the contents of the conflicted file with</p>

    <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
      contents of file in current branch
    	  =======
    	  contents of file in given branch
    	  &gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

    <p>but <em>do not</em> stage the result.  Treat a deleted file in a branch
    as an empty file.</p></li>
    <li><p>Once files have been updated according to the above, there are
    two possibilities:</p>

    <ul>
      <li>If <code>merge</code> did not result in any conflicted files, then
      merge should automatically commit with a message `Merged
      [current branch name] with [given branch name].</li>
      <li>Otherwise,
      merge should not automatically make a commit. Instead, it
      should print the message <code>Encountered a merge conflict.</code>,
      	  It is then up to the user to decide how to resolve the conflict
      	  (generally by editing the file and then staging it with <code>add</code>,
      	  or removing it with <code>rm</code>) and to commit the result.</li>
    </ul></li>
  </ul></li>
  <li><strong>Runtime</strong>: Should be linear in the lengths of the history
  of each branch plus the total size of
  new files added in commits in each branch.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name does not exist,
  print the error message <code>A branch with that name does not exist.</code> If
  attempting to merge a branch with itself, print the error message
  <code>Cannot merge a branch with itself.</code> If merge would generate an
  error because the commit that it does has no changes in it, just let
  the normal commit error message for this go through.</li>
  <li><strong>Dangerous?</strong>: Yes!</li>
  <li><p><strong>Differences from real git</strong>: There are quite a few. For one, in git, the
  new commit at the end of merge is special, because it maintains two
  back pointers remembering which two branches it came from. But
  gitlet only needs to maintain one normal back pointer on the current
  branch.</p>

  <p>Real git does a more subtle job of merging files, displaying conflicts only
  in places where both files have changed since the split point.</p>

  <p>Real git will force the user to resolve the merge
  conflicts before committing to complete the merge. Gitlet just
  allows users to commit to complete the merge whenever they want.</p></li>
</ul>

<!-- - __Our line count__: ~70 -->

<!--

#### rebase

<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rebase [branch name]</code></li>
  <li><p><strong>Description</strong>: Conceptually, what rebase does is find the split
  point of the current branch and the given branch, then snaps off the
  current branch at this point, then reattaches the current branch to
  the head of the given branch. Say we are on branch <code>branch</code> and we
  make the call <code>java gitlet.Main rebase master</code>: <img src="image/conceptual_rebase.png" alt="Conceptual
  rebase"> Now, this may prompt two
  questions:</p>

  <ul>
    <li><em>Why would you ever want to do this?</em> You can think of it as an
    alternative to merge, where instead of having two branches that
    come together, you just pretend as if one of the branches came
    after the other one. If you use it smartly, this can create a
    cleaner history than merge.</li>
    <li><em>Doesn't this ruin what you said about the commit tree being
    immutable?</em> Yes, it does! That's because we just lied to you in
    the picture above. In fact, rebase does not break off the
    current branch. Instead, it leaves the current branch there, but
    makes a <em>copy</em> of the current branch on top of the given branch
    (this is called <em>replaying</em> the branch). Then it moves the
    branch pointer to point to this copy, so that you can pretend
    you moved it. Here's the real picture: <img src="image/real_rebase.png" alt="Real
    rebase"> The replayed commits should
    have new ids, not copies of the original ids. This allows you to
    still access the original commits using their old ids, if you
    really wanted to. In addition, the replayed commits should have
    new time stamps, allowing you to distinguish them from the
    originals in <code>global&#x2d;log</code>.</li>
  </ul></li>
</ul>

Rebase has one special case to look out for. If the current branch
pointer is in the history of the given branch, rebase just moves the
current branch to point to the same commit that the given branch
points to. No commits are replayed in this case.

There's one more point to make about rebase: If the commit at the
front of the given branch has files that have been modified since the
split point, these these changes should _propagate through_ the
replay. This means, essentially, that the versions of the files in the
given branch should take the place of their counterparts in the
replayed commits, up until one of the replayed commits has a version
of the file that had also been modified since the split point. In this
case, what you might expect to happen is that you would get conflicted
files, much like merge. However, for simplicity, we're not going to
have you deal with conflicts in rebase: in this case, just keep the
current branch's copies of the files. The bottom line: A file from the
given branch stops propagating through once it meets a modified file
in the replayed branch.

Finally, after successfully replaying nodes, reset to the node at the
front of the replayed branch.

By the way, if there are multiple branches after the split point, you
should NOT replay the other branches. For example, say we are on
branch <code>branch1</code> and we make the call <code>java gitlet.Main rebase master</code>:
<img src="image/branching_rebase.png" alt="Branching rebase">

<ul>
  <li><strong>Runtime</strong>: Should be linear relative to the history of the current
  branch and the given branch. Should also be linear in terms of the
  number of files added to both branches. Should also be linear
  relative to the total size of files added to the given branch. Also,
  be aware that rebase should not need to make any additional backup
  copies of files.</li>
  <li><strong>Failure cases</strong>: If a branch with the given name does not exist,
  print the error message <code>A branch with that name does not exist.</code> If
  the given branch name is the same as the current branch name, print
  the error message <code>Cannot rebase a branch onto itself.</code> If the input
  branch's head is in the history of the current branch's head, print
  the error message <code>Already up&#x2d;to&#x2d;date.</code></li>
  <li><strong>Dangerous?</strong>: Yes.</li>
  <li><strong>Differences from the real git</strong>: The real git's rebase is a
  complicated and many-flagged command. Gitlet's rebase really only
  gets at the core idea. In particular, the way it handles
  conflicts is much different! For instance, the real rebase will
  pause when it encounters a conflict, make the user fix it, and then
  continue on after.</li>
</ul>

-->

<!-- - __Our line count__: ~70 -->


<h2 id="e-miscellaneous-things-to-know-about-the-project">E. Miscellaneous Things to Know about the Project</h2>


<p>Phew! That was a lot of commands to go over just now. But don't worry,
not all commands are created equal. You can see for each command the
approximate number of lines we took to do each part (that this
only counts code specific to that command — it doesn't double-count
code reused in multiple commands). You shouldn't worry about matching
our solution exactly, but hopefully it gives you an idea about the
relative time consumed by each command. Merge is
a lengthier command than the others, so don't leave it for the
last minute!</p>

<p>Anyway, by now this spec has given you enough information to get
working on the project. But to help you out some more, there are a
couple of things you should be aware of:</p>


<h2 id="dealing-with-files">Dealing with Files</h2>

<p>This project requires reading and writing of files. In order to do
these operations, you might find the classes <code>java.io.File</code> and
<code>java.nio.file.Files</code> helpful. Actually, you may find various things
in the <code>java.io</code> and <code>java.nio</code> packages helpful. Be sure to read the
gitlet.Utils package for other things we've written for you.
If you do a little
digging through all of these, you might find a couple of methods that will
make the io portion of this project <em>much</em> easier! One warning: If
you find yourself using readers, writers, scanners, or streams,
you're making things more complicated than need be.
all.</p>


<h2 id="serialization-details">Serialization Details</h2>

<p>If you think about gitlet, you'll notice that you can only run one
command every time you run the program. In order to successfully
complete your version-control system, you'll need to remember the
commit tree across commands. This means you'll have to design not just a
set of classes to represent internal <code>gitlet</code> structures during execution,
but you'll a parallel representation as files within your <code>.gitlet</code>
directories, which will carry across multiple runs of your program.</p>

<p>As indicated earlier, the convenient way to do this is to serialize
the runtime objects that you will also need to store permanently in files.
In Java, this simply involves implementing
the <code>java.io.Serializable</code> interface:</p>

<pre><code>import java.io.Serializable;

class MyObject implements Serializable {</code></pre>

<p>...</p>

<pre><code>}</code></pre>

<p>This interface has no methods; it simply marks its subtypes for the benefit
of some special Java classes for performing I/O on objects.  For example,</p>

<pre><code>import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
...</code></pre>

<p>MyObject obj = ....;
	File outFile = new File(someFileName);
	try {
	    ObjectOutputStream out =
		new ObjectOutputStream(new FileOutputStream(outFile));
	    out.writeObject(obj);
	    out.close();
	} catch (IOException excp) {
	    ...
	}</p>

<p>will convert <code>obj</code> to a stream of bytes and store them in the file whose
name is stored in <code>someFileName</code>.  The object may then be reconstructed with
a code sequence such as</p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
...</code></pre>

<p>MyObject obj;
	File inFile = new File(someFileName);
	try {
	    ObjectInputStream inp =
		new ObjectInputStream(new FileInputStream(inFile));
	    obj = (MyObject) inp.readObject(obj);
	    inp.close();
	} catch (IOException excp) {
	    ...
	    obj = null;
	}</p>

<p>The Java runtime does all the work of figuring out what fields need to be
converted to bytes and how to do so.</p>

<p>There is, however, one annoying subtlety to watch out for: Java serialization
follows pointers.  That is, not only is the object you pass into <code>writeObject</code>
serialized and written, but any object it points to as well.  If your internal
representation of commits, for example, represents the parent commit as a
pointer to another commit object, then writing the head of a branch will
write all the commits (and blobs) in the entire chain of commits
into one file, which is generally not what you want.  With a little work, you
can avoid this problem.  One technique is simply not to use Java pointers to
refer to commits and blobs in your runtime objects, but instead to use
SHA-1 hash strings.  You then have a runtime map between these strings
and the runtime objects they refer to.  You create and fill in this map
while <code>gitlet</code> is running, but never read or write it to a file.</p>


<h2 id="f-testing">F. Testing</h2>


<p>[We'll be releasing a skeleton testing structure soon.  Please watch for an
announcement.]</p>

<!--
So far in this course we've introduced you to _unit testing_. These
tests test small parts of your code in isolation, such as individual
methods. Unit tests, however, may not be sufficient for verifying the
correctness of large and complicated systems. Another type of test,
_end-to-end tests_, may be helpful. End-to-end tests test higher level
behavior of a system. They don't just test individual methods; they
test whether the complete system provides its expected functionality
as the user would experience it.

For this project, you'll be required to submit _both_ some unit tests
and some end-to-end tests. Please _at least_ provide the following end-
to-end tests:

<ul>
  <li>Test that a file that has been committed at some point can be
  restored by checking it out from the commit it was committed at.</li>
  <li>Test that a file that has been committed at some point can be
  restored by checking it out from a commit that tracks that version
  of the file, even if the file wasn't staged prior to that commit.</li>
  <li>Test that you can <code>checkout [id] [file]</code> from an arbitrary commit in
  the graph (even one in another branch).</li>
  <li>Test that resetting backward appropriately changes the output of
  log.</li>
  <li>Test that log adjusts appropriately when switching from one branch
  to another.</li>
  <li>Test that merge will generate a .conflicted file if a file has been
  modified in both branches since the split point.</li>
  <li>Test that merge will commit with files from the other branch if
  those files had been modified in the other branch but not in the
  current branch since the split point.</li>
</ul>

<!--

<ul>
  <li>Test that the output of log after a rebase includes the commit
  messages from both branches involved in the rebase.-->
  <li>Test that changes in the base branch propagate through the replayed
  branch during a rebase. --&gt;</li>


These are just basic ones we're requiring you to have to get you
started. You should of course do more of your own testing to ensure
your code is fully correct! You should also provide unit tests where
you feel they are more appropriate. Although unit tests are not
strictly required, we may use them to give partial credit in case your
project catastrophically fails in the autograder.

You can write unit tests just as you always have done in this course:
using JUnit. But how do you write end-to-end tests? The point of the
end-to-end tests is that they should simulate how the user would
interact with gitlet, that is, using the terminal. The most
straightforward way to write end-to-end tests would be to use shell
scripting — this is essentially just automating terminal commands.
However, since you're not required to be familiar with shell scripting
for this course, we recommend you to just use JUnit even for your end-
to-end testing, although it is a little awkward. JUnit, as its name
suggests, was really designed for unit testing.

To help you over this awkwardness, we've written some example end-to-
end tests you can look at in <a href="https://inst.eecs.berkeley.edu/~cs61b/fa15/hw/proj3/%3Chome-page-link%3Ecode/proj2.zip">GitletTest.java</a>. We recommend you pattern your own after these.
They use a helper method called <code>gitlet</code>, which calls your code
by executing a terminal command that calls Java. For end-to-end tests,
this is the only way you should interact with your code; you shouldn't
call your methods directly.

By the way, you should also try running your code from the command
line and use it just like git! Don't _only_ test with JUnit. In
addition, if you're using Windows, __be sure to test out your code and
tests on a unix/linux/mac machine, such as the lab computers__. You
want to make sure that your code does not only work in a Windows
environment, since our autograders will be run in Linux.

--&gt;


<h2 id="g-submission-grading-and-checkpoints">G. Submission, Grading, and Checkpoints</h2>


<p>Submit your project by putting it in a directory called <code>proj3</code> and submitting
in the usual way.</p>

<p>About grading: 
We will test your project by using canned sequences of <code>gitlet</code> command and
checking the output, so be sure you conform to the various specs for
output and error messages.
If any of the core functionality is broken
(namely <code>add</code>, <code>commit</code>, <code>checkout</code>, or <code>log</code>), then many of our tests
may break, and you will end up with few points. Make sure they work
exactly as the spec describes! Although the fringe functionality is
more difficult and time consuming to write (like <code>merge</code>),
fewer tests depend on these methods, so they won't impact
your grade as much.</p>


<h2 id="h-extra-credit-going-remote">H. Extra Credit: Going Remote</h2>


<p>This project is all about mimicking git's local features. These are
useful because they allow you to backup your own files and maintain
multiple versions of them. However, git's true power is really in its
<em>remote</em> features, allowing collaboration with other people over the
internet. The point is that both you and your friend could be
collaborating on a single code base. If you make changes to the files,
you can send them to your friend, and vice versa. And you'll both have
access to a shared history of all the changes either of you have made.</p>

<p>To get extra credit, implement some basic remote commands:
namely <code>add-remote</code>, <code>rm-remote</code>, <code>push</code>, <code>fetch</code>, and <code>pull</code>
You will get 5 extra-credit points for completing them. 
Don't attempt or plan for extra credit until you have completed the
rest of the project.</p>

<p>Depending on how flexibly you have designed the rest of the project,
5 extra-credit points
may not be worth the amount of effort it takes to do this section.
We're certainly not expecting everyone to do it.
Our priority will be in helping students complete the main project;
if you're doing the
extra credit, we expect you to be able to stand on your own a little
bit more than most students.</p>


<h2 id="the-commands">The Commands</h2>


<p>All right, now that you've gotten scp working, onto the rest of the
project!</p>

<p>A few notes about the remote commands:</p>

<ul>
  <li>Execution time will not be graded. For your own edification, please don't
  do anything ridiculous, though.</li>
  <li>All the commands are significantly simplified from their git
  equivalents, so specific differences from git are usually not
  notated. Be aware they are there, however.</li>
</ul>

<p>So now let's go over the commands:</p>


<h4 id="add-remote">add-remote</h4>


<ul>
  <li><strong>Usage</strong>: `java gitlet.Main add-remote [remote name] file://[name of remote directory]/.gitlet</li>
  <li><strong>Description</strong>: Saves the given login information under the given
  remote name. Attempts to push or pull from the given remote name
  will then attempt to use this .gitlet directory.  In real life, file
  URLs (starting with <code>file://</code>) contain complete paths such as
    java gitlet.Main add-remote other file:///home/cc/cs61b-xx/otherdir/.gitlet
  However, we allow paths relative to the git working directory in which you
  run <code>java gitlet.Main</code>, such as
    java gitlet.Main add-remote other file://../testing/otherdir/.gitlet
  This allows you to provide tests of remotes that will work from all 
  locations (on your home machine or within the grading program's software).</li>
  <li><strong>Failure cases</strong>: If a remote with the given name already exists,
  print the error message: <code>A remote with that name already exists.</code>
  You don't have to check if the user name and server
  information are legit.</li>
  <li><strong>Dangerous?</strong>: No.</li>
</ul>


<h4 id="rm-remote">rm-remote</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main rm-remote [remote name]</code></li>
  <li><strong>Description</strong>: Remove information associated with the given remote
  name. The idea here is that if you ever wanted to change a remote
  that you added, you would have to first remove it and then re-add
  it.</li>
  <li><strong>Failure cases</strong>: If the given remote name has not been added,
  print <code>A remote with that name does not exist.</code> If a remote with the
  given name does not exist, print the error message: <code>A remote with
  that name does not exist.</code></li>
  <li><strong>Dangerous?</strong>: No.</li>
</ul>


<h4 id="push">push</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main push [remote name] [remote branch name]</code></li>
  <li><p><strong>Description</strong>: Attempts to append the current branch's commits to
  the end of the given branch at the given remote. Details:</p>

  <p>This command only works if the remote branch's head is in the
  history of the current local head, which means that the local
  branch contains some commits in the future of the remote branch.
  In this case, append the future commits to the remote branch.
  Then, the remote should reset to the front of the appended
  commits (so its head will be the same as the local head). This
  is called fast-forwarding.</p>

  <p>If the gitlet system on the remote machine exists but does not
  have the input branch, then simply add the branch to the remote
  gitlet.</p></li>
  <li><strong>Failure cases</strong>: If the remote branch's head is not in the history
  of the current local head, print the error message <code>Please pull down
  remote changes before pushing.</code>  If the remote <code>.gitlet</code> directory does not
  exist, print <code>Remote directory not found.</code></li>
  <li><strong>Dangerous?</strong>: No.</li>
</ul>


<h4 id="fetch">fetch</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main fetch [remote name] [remote branch name]</code></li>
  <li><strong>Description</strong>: Brings down commits from the remote gitlet into the
  local gitlet. Basically, this copies all commits and blobs from the given
  branch in the remote repository (that are not already in the current
  repository) into a branch named <code>[remote name]/[remote branch name]</code> in the
  local <code>.gitlet</code> (just
  as in real <code>git</code>), changing <code>[remote name]/[remote branch name]</code> to point
  to the head commit (thus copying the contents of the branch from the remote
  repository to the current one).  This branch is created in the local
  repository if it did not previously exist.</li>
  <li><strong>Failure cases</strong>: If the remote gitlet does not have the given
  branch name, print the error message <code>That remote does not have that
  branch.</code>  If the remote <code>.gitlet</code> directory does not
  exist, print <code>Remote directory not found.</code></li>
  <li><strong>Dangerous?</strong> No</li>
</ul>


<h4 id="pull">pull</h4>


<ul>
  <li><strong>Usage</strong>: <code>java gitlet.Main pull [remote name] [remote branch name]</code></li>
  <li><strong>Description</strong>: Fetches branch <code>[remote name]/[remote branch name]</code> as
  for the <code>fetch</code> command, and then merges that fetch into the current branch.</li>
  <li><strong>Failure cases</strong>: Just the failure cases of <code>fetch</code> and <code>merge</code>
  together.</li>
  <li><strong>Dangerous?</strong> Yes!</li>
</ul>


<h2 id="i-acknowledgments">I. Acknowledgments</h2>


<p>Thanks to Alicia Luengo, Josh Hug, Sarah Kim, Austin Chen, Andrew
Huang, Yan Zhao, Matthew Chow, especially Alan Yao, Daniel Nguyen, and
Armani Ferrante for providing feedback on this project. Thanks to git
for being awesome.</p>

<p>This project was largely inspired by <a href="http://www.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/">this</a> excellent article by Philip Nilsson.</p>

<p>This project was created by Joseph Moghadam.  Modifications for Fall 2015 by
Paul Hilfinger.</p>
    </main>



</body></html>